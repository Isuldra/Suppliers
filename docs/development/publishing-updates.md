# Publishing Updates

This guide explains how to prepare and manually publish updates for SupplyChain OneMed.

## Overview

SupplyChain OneMed uses [electron-updater](https://www.electron.build/auto-update) to handle automatic updates once a release is published. The CI pipeline builds the application artifacts (installers, portable versions), but **publishing these artifacts to GitHub Releases is a manual process.**

## Prerequisites

Before preparing an update for manual publishing, ensure you have:

1. **GitHub Access**: Write access to the GitHub repository where releases are hosted.
2. **Version Control**: All changes for the release are committed and pushed to the main branch.
3. **Clean Working Directory**: No uncommitted changes locally.
4. **CI Build**: A successful CI build (e.g., from a tagged commit) has generated the required artifacts (`.exe` installer, portable `.exe`).

## Manual Publishing Process

### 1. Determine and Update Version Number

Decide on the new version number following [semantic versioning](https://semver.org/) principles:

- **MAJOR** version for incompatible API changes (`1.0.0` → `2.0.0`)
- **MINOR** version for added functionality in a backwards compatible manner (`1.0.0` → `1.1.0`)
- **PATCH** version for backwards compatible bug fixes (`1.0.0` → `1.0.1`)

Update the `version` field in `package.json`:

```json
{
  "name": "supplychain-onemed",
  "version": "1.0.1",
  "description": "Desktop application for managing supply chain data for OneMed"
}
```

Commit and push this change. Optionally, create a Git tag matching the version (e.g., `v1.0.1`). Triggering the CI pipeline on this commit/tag is recommended.

### 2. Build Artifacts (Locally or via CI)

Ensure the application artifacts are built with the correct version number baked in.

- **Using CI (Recommended):** If the CI pipeline runs on tags or the main branch after the version bump, it will automatically build the artifacts. Proceed to Step 3.
- **Building Locally (Alternative):** If you need to build manually:

  ```bash
  # Ensure dependencies are installed
  npm install

  # Build the renderer/frontend
  npm run build

  # Create distribution packages (installer, portable, etc.)
  # Ensure this command builds all necessary artifacts
  # e.g., build NSIS installer and portable
  npm run dist:nsis
  npm run dist:portable
  ```

  The artifacts will typically be located in the `release` folder.

### 3. Retrieve Artifacts

- **From CI:** Navigate to the successful GitHub Actions run (associated with your version commit/tag). Download the build artifacts (e.g., `Supplier-Reminder-Pro-Windows-x64` which contains the `release` folder contents).
- **From Local Build:** Locate the generated installer (`OneMed SupplyChain-[version]-setup.exe`), the portable executable (`OneMed SupplyChain-Portable.exe`), and the update metadata file (e.g., `latest.yml`) in your local `release` directory.

### 4. Create GitHub Release and Upload Artifacts

1. Go to your project's GitHub repository page.
2. Click on the "Releases" link.
3. Click "Draft a new release".
4. **Tag version:** Choose or create the Git tag matching the version (e.g., `v1.0.1`).
5. **Release title:** Enter a title (e.g., `v1.0.1`).
6. **Describe this release:** Write release notes/changelog.
7. **Attach binaries:** Drag and drop or select the built artifact files:
   - The installer (`OneMed SupplyChain-[version]-setup.exe`).
   - The portable executable (`OneMed SupplyChain-Portable.exe`).
   - **Crucially, also upload the `latest.yml` file** generated alongside the installer. `electron-updater` needs this file on the release to find the update.
   - (Optional) Upload other artifacts like `.msi` if built.
8. **Pre-release:** Check this box if applicable.
9. Click "Publish release".

### 5. Verify the Release

After publishing manually:

1. Check the GitHub Releases page to ensure the release looks correct.
2. Verify all intended assets are attached.
3. Double-check the release notes.
4. **Crucially:** Install a previous version of the application and trigger the "Check for Updates" functionality to confirm it correctly detects and can download the new version from the manual GitHub release.

## Advanced Configuration Notes

- **Release Channels:** While `electron-builder` supports channels (`beta`, `alpha`), managing these with manual uploads requires careful naming conventions or separate releases if needed.
- **Staged Rollouts:** True staged rollouts are complex with manual GitHub releases. Consider alternative deployment strategies if this is required.

## Troubleshooting

### Common Issues

#### Users Not Receiving Updates

- **Version Check:** Ensure the `version` in the released `package.json` (baked into the app) is higher than the user's current version.
- **GitHub Release:** Verify the release is published (not a draft) on GitHub.
- **Assets:** Confirm the correct artifact files (installer, `latest.yml` generated by builder) were manually uploaded to the GitHub release. `electron-updater` relies on these specific files being present.
- **Firewall/Network:** Ensure users can reach GitHub.com to check for updates.

## Best Practices

1. **Maintain a Changelog**: Essential for release notes.
2. **Test Artifacts**: Thoroughly test the exact artifacts generated by CI/build _before_ uploading.
3. **Communicate Updates**: Inform users about new releases.
4. **Versioning Strategy**: Stick to semantic versioning.
5. **Backup**: Keep backups of code and release artifacts.
6. **Rollback Plan**: Know how to unpublish a release or guide users if a rollback is needed.

## Reference

- [Electron Builder Documentation](https://www.electron.build/)
- [Electron Updater Documentation](https://www.electron.build/auto-update)
- [GitHub Releases API](https://docs.github.com/en/rest/releases)
- [Semantic Versioning](https://semver.org/)
